namespace main(8);
pol commit _operation_id;
pol commit _sigma;
pol constant _romgen_first_step = [1] + [0]*;
_sigma' = ((1 - _romgen_first_step') * (_sigma + instr_return));
(_sigma * (_operation_id - 7)) = 0;
pol commit pc;
pol commit X;
pol commit Y;
pol commit reg_write_X_A;
pol commit reg_write_Y_A;
pol commit A;
pol commit instr_incr;
(instr_incr * (Y - (X + 1))) = 0;
pol commit instr_decr;
(instr_decr * (Y - (X - 1))) = 0;
pol commit instr_assert_zero;
(instr_assert_zero * (X - 0)) = 0;
pol commit instr_mstore;
instr_mstore { addr, STEP, X } is m_is_write { m_addr, m_step, m_value };
pol commit instr_mload;
instr_mload { addr, STEP, X } is m_is_read { m_addr, m_step, m_value };
pol commit instr__jump_to_operation;
pol commit instr__reset;
pol commit instr__loop;
pol commit instr_return;
pol commit X_const;
pol commit X_read_free;
pol commit read_X_A;
pol commit read_X_pc;
X = ((((read_X_A * A) + (read_X_pc * pc)) + X_const) + (X_read_free * X_free_value));
pol commit Y_const;
pol commit Y_read_free;
pol commit read_Y_A;
pol commit read_Y_pc;
Y = ((((read_Y_A * A) + (read_Y_pc * pc)) + Y_const) + (Y_read_free * Y_free_value));
pol constant first_step = [1] + [0]*;
A' = ((((reg_write_X_A * X) + (reg_write_Y_A * Y)) + (instr__reset * 0)) + ((1 - ((reg_write_X_A + reg_write_Y_A) + instr__reset)) * A));
pol pc_update = ((((instr__jump_to_operation * _operation_id) + (instr__loop * pc)) + (instr_return * 0)) + ((1 - ((instr__jump_to_operation + instr__loop) + instr_return)) * (pc + 1)));
pc' = ((1 - first_step') * pc_update);
pol constant p_line = [0, 1, 2, 3, 4, 5, 6, 7] + [7]*;
pol commit X_free_value(i) query match pc { 2 => ("input", 0), };
pol commit Y_free_value(i) query match pc {  };
pol constant p_X_const = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_X_read_free = [0, 0, 1, 0, 0, 0, 0, 0] + [0]*;
pol constant p_Y_const = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_Y_read_free = [0, 0, 0, 1, 1, 0, 0, 0] + [0]*;
pol constant p_instr__jump_to_operation = [0, 1, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_instr__loop = [0, 0, 0, 0, 0, 0, 0, 1] + [1]*;
pol constant p_instr__reset = [1, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_instr_assert_zero = [0, 0, 0, 0, 0, 1, 0, 0] + [0]*;
pol constant p_instr_decr = [0, 0, 0, 0, 1, 0, 0, 0] + [0]*;
pol constant p_instr_incr = [0, 0, 0, 1, 0, 0, 0, 0] + [0]*;
pol constant p_instr_mload = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_instr_mstore = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_instr_return = [0, 0, 0, 0, 0, 0, 1, 0] + [0]*;
pol constant p_read_X_A = [0, 0, 0, 1, 1, 1, 0, 0] + [0]*;
pol constant p_read_X_pc = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_read_Y_A = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_read_Y_pc = [0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
pol constant p_reg_write_X_A = [0, 0, 1, 0, 0, 0, 0, 0] + [0]*;
pol constant p_reg_write_Y_A = [0, 0, 0, 1, 1, 0, 0, 0] + [0]*;
{ pc, reg_write_X_A, reg_write_Y_A, instr_incr, instr_decr, instr_assert_zero, instr_mstore, instr_mload, instr__jump_to_operation, instr__reset, instr__loop, instr_return, X_const, X_read_free, read_X_A, read_X_pc, Y_const, Y_read_free, read_Y_A, read_Y_pc } in { p_line, p_reg_write_X_A, p_reg_write_Y_A, p_instr_incr, p_instr_decr, p_instr_assert_zero, p_instr_mstore, p_instr_mload, p_instr__jump_to_operation, p_instr__reset, p_instr__loop, p_instr_return, p_X_const, p_X_read_free, p_read_X_A, p_read_X_pc, p_Y_const, p_Y_read_free, p_read_Y_A, p_read_Y_pc };
pol constant _block_enforcer_last_step = [0]* + [1];
pol commit _operation_id_no_change;
_operation_id_no_change = ((1 - _block_enforcer_last_step) * (1 - instr_return));
(_operation_id_no_change * (_operation_id' - _operation_id)) = 0;
pol constant _linker_first_step = [1] + [0]*;
(_linker_first_step * (_operation_id - 2)) = 0;
