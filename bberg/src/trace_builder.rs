use number::FieldElement;

fn trace_includes() -> String {
    r#"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <sys/types.h>
#include <vector>
"#
    .to_owned()
}

// Create trace builder
// Generate some code that can read a commits.bin and constants.bin into data structures that bberg understands
pub fn create_trace_buidler<F: FieldElement>(
    name: &str,
    fixed: &[(&str, Vec<F>)],
    witness: &[(&str, Vec<F>)],
) -> String {
    // We are assuming that the order of the columns in the trace file is the same as the order in the witness file
    let includes = trace_includes();
    let row_import = format!("using Row = {name}::{name}Row<barretenberg::fr>;");

    let fixed_rows = fixed
        .iter()
        .map(|(name, _)| format!("current_row.{name} = read_file(constants_filename);"))
        .collect::<Vec<_>>()
        .join("\n");

    let wit_rows = witness
        .iter()
        .map(|(name, _)| {
            let n = name.replace(".", "_");
            format!(
                "
        current_row.{n} = read_file(commited_filename);
        current_row.{n}_shift = read_file(constants_filename);"
            )
        })
        .collect::<Vec<_>>()
        .join("\n");

    // NOTE: can we assume that the witness filename etc will stay the same?
    let read_from_file_boilerplate = format!(
        "
// AUTOGENERATED FILE
{includes}

using namespace barretenberg;
using fr = barretenberg::fr;

{row_import}
fr read_field(std::ifstream& file)
{{
    uint8_t buffer[32];
    file.read(reinterpret_cast<char*>(buffer), 32);

    // swap it to big endian ???? TODO: create utility
    for (int n = 0, m = 31; n < m; ++n, --m) {{
        std::swap(buffer[n], buffer[m]);
    }}

    return fr::serialize_from_buffer(buffer);
}}
    
std::vector<Row> read_both_file_into_cols(
    std::string commited_filename,
    std::string constants_filename,
) {{
    std::vector<Row> rows;

    // open both files
    std::ifstream commited_file(commited_filename, std::ios::binary);
    if (!commited_file) {{
        std::cout << 'Error opening commited file' << std::endl;
        return {{}};
    }}

    std::ifstream constant_file(constant_filename, std::ios::binary);
    if (!constant_file) {{
        std::cout << 'Error opening constant file' << std::endl;
        return {{}};
    }}

    // We are assuming that the two files are the same length
    while (commited_file) {{
        Row current_row = {{}};

        {fixed_rows}
        {wit_rows}

        rows.push_back(current_row);
    }}

    return rows;
}}
    "
    );

    println!("{}", &read_from_file_boilerplate);
    read_from_file_boilerplate
}
