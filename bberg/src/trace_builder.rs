use number::FieldElement;

use crate::circuit_builder::BBFiles;

pub trait TraceBuilder {
    fn create_trace_builder<F: FieldElement>(
        &mut self,
        name: &str,
        fixed: &[(&str, Vec<F>)],
        witness: &[(&str, Vec<F>)],
    ) -> String;
}

fn trace_includes(relation_path: &str, name: &str) -> String {
    let boilerplate = r#"
#include "barretenberg/ecc/curves/bn254/fr.hpp"
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <sys/types.h>
#include <vector>
#include "barretenberg/proof_system/arithmetization/arithmetization.hpp"
#include "barretenberg/proof_system/circuit_builder/execution_trace_builder_base.hpp"
"#
    .to_owned();

    format!(
        "
{boilerplate}
#include \"barretenberg/{relation_path}/{name}.hpp\"
#include \"barretenberg/proof_system/arithmetization/generated/{name}_arith.hpp\"
"
    )
}

fn build_shifts(fixed: Vec<String>) -> String {
    let shift_assign: Vec<String> = fixed
        .iter()
        .map(|name| format!("row.{name}_shift = rows[(i+1) % rows.size()].{name};"))
        .collect();

    format!(
        "
    for (size_t i = 0; i < rows.size(); ++i) {{
        Row& row = rows[i];
        {}
        
    }}
    ",
        shift_assign.join("\n")
    )
}

impl TraceBuilder for BBFiles {
    // Create trace builder
    // Generate some code that can read a commits.bin and constants.bin into data structures that bberg understands
    fn create_trace_builder<F: FieldElement>(
        &mut self,
        name: &str,
        fixed: &[(&str, Vec<F>)],
        witness: &[(&str, Vec<F>)],
    ) -> String {
        // We are assuming that the order of the columns in the trace file is the same as the order in the witness file
        let includes = trace_includes(&self.rel, &name);
        let row_import = format!("using Row = {name}_vm::Row<barretenberg::fr>;");

        // TODO: Recalculated!
        let num_cols = fixed.len() + witness.len() * 2; // (2* as shifts)

        let fixed_rows = fixed
            .iter()
            .map(|(name, _)| {
                let n = name.replace(".", "_");
                format!("current_row.{n} = read_field(constant_file);")
            })
            .collect::<Vec<_>>()
            .join("\n");

        let wit_names = witness
            .iter()
            .map(|(name, _)| name.replace(".", "_"))
            .collect::<Vec<_>>();
        let wit_rows = wit_names
            .iter()
            .map(|n| {
                format!(
                    "
        current_row.{n} = read_field(commited_file);"
                )
            })
            .collect::<Vec<_>>()
            .join("\n");

        let construct_shifts = build_shifts(wit_names);

        // NOTE: can we assume that the witness filename etc will stay the same?
        let read_from_file_boilerplate = format!(
            "
// AUTOGENERATED FILE
{includes}

using namespace barretenberg;
using fr = barretenberg::fr;

namespace proof_system {{

{row_import}
fr read_field(std::ifstream& file)
{{
    uint8_t buffer[32];
    file.read(reinterpret_cast<char*>(buffer), 32);

    // swap it to big endian ???? TODO: create utility
    for (int n = 0, m = 31; n < m; ++n, --m) {{
        std::swap(buffer[n], buffer[m]);
    }}

    return fr::serialize_from_buffer(buffer);
}}
    
std::vector<Row> read_both_file_into_cols(
    std::string const& commited_filename,
    std::string const& constants_filename
) {{
    std::vector<Row> rows;

    // open both files
    std::ifstream commited_file(commited_filename, std::ios::binary);
    if (!commited_file) {{
        std::cout << \"Error opening commited file\" << std::endl;
        return {{}};
    }}

    std::ifstream constant_file(constants_filename, std::ios::binary);
    if (!constant_file) {{
        std::cout << \"Error opening constant file\" << std::endl;
        return {{}};
    }}

    // We are assuming that the two files are the same length
    while (commited_file) {{
        Row current_row = {{}};

        {fixed_rows}
        {wit_rows}

        rows.push_back(current_row);
    }}

    // remove the last row - TODO: BUG!
    rows.pop_back();

    // Build out shifts from collected rows
    {construct_shifts}


    return rows;
}}

class {name}TraceBuilder : public ExecutionTraceBuilderBase<arithmetization::{name}Arithmetization> {{
    public:
        using FF = arithmetization::{name}Arithmetization::FF;
        using Row = {name}_vm::Row<FF>;

        static constexpr size_t num_fixed_columns = {num_cols};
        std::vector<Row> rows;


        [[maybe_unused]] build_circuit() {{
            rows = read_both_file_into_cols(\"../commits.bin\", \"../constants.bin\");
        }}

        [[maybe_unused]] bool check_circuit() {{
            // Get the rows from file
            build_circuit();

            return evaluate_relation<{name}_vm::{name}<FF>, Row>(\"{name}\", rows);
        }}

        [[nodiscard]] size_t get_num_gates() const {{ return rows.size(); }}

        [[nodiscard]] size_t get_circuit_subgroup_size() const
        {{
            const size_t num_rows = get_num_gates();
            const auto num_rows_log2 = static_cast<size_t>(numeric::get_msb64(num_rows));
            size_t num_rows_pow2 = 1UL << (num_rows_log2 + (1UL << num_rows_log2 == num_rows ? 0 : 1));
            return num_rows_pow2;
        }}


}};
}}
    "
        );

        // TODO: remove return val, make traits for everything
        self.trace_hpp = Some(read_from_file_boilerplate.clone());
        read_from_file_boilerplate
    }
}
